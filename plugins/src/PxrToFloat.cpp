/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2019 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixPattern.h"
#include "RixShadingUtils.h"

class PxrToFloat : public RixPattern
{
public:

    PxrToFloat();
    virtual ~PxrToFloat();

    virtual int Init(RixContext &, RtUString const pluginpath) override;
    virtual RixSCParamInfo const *GetParamTable() override;

    virtual void Synchronize(
        RixContext&,
        RixSCSyncMsg,
        RixParameterList const*) override
    {
    }

    virtual void Finalize(RixContext &) override;

    virtual int ComputeOutputParams(RixShadingContext const *,
                                    RtInt *n, RixPattern::OutputSpec **outputs,
                                    RtPointer instanceData,
                                    RixSCParamInfo const *) override;

    virtual bool Bake2dOutput(
        RixBakeContext const*,
        Bake2dSpec&,
        RtPointer) override
    {
        return false;
    }

    virtual bool Bake3dOutput(
        RixBakeContext const*,
        Bake3dSpec&,
        RtPointer) override
    {
        return false;
    }

private:
    // Defaults
    RtInt const m_mode;
    RtColorRGB const m_input;

    RixMessages *m_msg;
};


PxrToFloat::PxrToFloat() :
    m_mode(0),
    m_input(0.0f, 0.0f, 0.0f),
    m_msg(NULL)
{
}

PxrToFloat::~PxrToFloat()
{
}

int
PxrToFloat::Init(RixContext &ctx, RtUString const pluginpath)
{
    PIXAR_ARGUSED(pluginpath);

    m_msg = (RixMessages*)ctx.GetRixInterface(k_RixMessages);

    if (!m_msg)
        return 1;

    return 0;
}
enum paramId
{
    k_resultF=0,    // float output
    k_input,
    k_mode,
    k_numParams
};

RixSCParamInfo const *
PxrToFloat::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        //outputs
        RixSCParamInfo(RtUString("resultF"),  k_RixSCFloat, k_RixSCOutput),

        // inputs - constant
        RixSCParamInfo(RtUString("input"), k_RixSCColor),
        RixSCParamInfo(RtUString("mode"), k_RixSCInteger),

        RixSCParamInfo(), // empty, end of table
    };
    return &s_ptable[0];
}

void
PxrToFloat::Finalize(RixContext &ctx)
{
    PIXAR_ARGUSED(ctx);
}


int
PxrToFloat::ComputeOutputParams(RixShadingContext const *sctx,
                                RtInt *noutputs, OutputSpec **outputs,
                                RtPointer instanceData,
                                RixSCParamInfo const *ignored)
{
    PIXAR_ARGUSED(instanceData);
    PIXAR_ARGUSED(ignored);

    bool varying = true;
    bool uniform = false;

    // evaluate input parameters
    RtColorRGB const *inputC;
    sctx->EvalParam(k_input, -1, &inputC, &m_input, varying);

    RtInt const *mode;
    sctx->EvalParam(k_mode, -1, &mode, &m_mode, uniform);
    RtInt umode = mode[0];

     // Find the number of outputs
    RixSCParamInfo const* paramTable = GetParamTable();
    int numOutputs = -1;
    while (paramTable[++numOutputs].access == k_RixSCOutput) {}

    // Allocate and bind our outputs
    RixShadingContext::Allocator pool(sctx);
    OutputSpec *o = pool.AllocForPattern<OutputSpec>(1);
    *outputs = o;
    *noutputs = 1;
    RtFloat *resultF = NULL;

    resultF = pool.AllocForPattern<RtFloat>(sctx->numPts);

    o[0].paramId = k_resultF;
    o[0].detail  = k_RixSCVarying;
    o[0].value = (RtPointer) resultF;


    // loop over our points
    for (int i = 0; i < sctx->numPts; i++)
    {
        // compute
        switch (umode)
        {
            case 0:
                resultF[i] = inputC[i].r;
                break;
            case 1:
                resultF[i] = inputC[i].g;
                break;
            case 2:
                resultF[i] = inputC[i].b;
                break;
            case 3:
                resultF[i] = inputC[i].Luminance();
                break;
            case 4:
                resultF[i] = inputC[i].ChannelAvg();
                break;
            default:
                resultF[i] = 0.5f;
                break;
        }
    }

    return 0;
}

RIX_PATTERNCREATE
{
    PIXAR_ARGUSED(hint);

    return new PxrToFloat();
}

RIX_PATTERNDESTROY
{
    delete ((PxrToFloat*)pattern);
}